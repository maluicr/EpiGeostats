---
title: "Documentation on blockdss"
author: "Manuel Ribeiro"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Documentation on blockdss}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## blockdss

blockdss R package generates geostatistical disease maps using block direct sequential simulation algorithm. 

It may also be used for similar problems such as mortality rates, or applied to other fields like ecology or criminology. Details on the geostatistical algorithm used in blockdss are described in Azevedo et al (https://doi.org/10.1186/s12942-020-00221-5).

## R wrapper

blockdss R package is a wrapper for running dss.c.64.exe - a software tool for running geostatistical algorithms - and pixelate, an R package for creating geostatistical maps with varying pixel sizes to represent disease mapping and spatial uncertainty in a single-map.

This package provides convenient wrappers to write data frames in format readable by dss.c.64.exe (geoEAS), setting the required parameters, running block direct sequential simulation algorithm, reading the files generated by dss.c.64.exe, and creating pixelated spatially continuous predictions as per their average uncertainty.

## Getting started

The stand-alone software dss.c.64.exe is required to run blockdss. Therefore, the first step is to **download dss.c.64.exe** from https://github.com/maluicr/dss (please follow download instructions available in the readme file from dss repository).

Then, install the required packages using the following code: 

```{r, eval = F}
# install devtools from CRAN
if (!require("devtools")){
  install.packages("devtools")
  }
  
  # install packages from GitHub
  devtools::install_github("maluicr/blockdss", dependencies = TRUE)
  devtools::install_github("aimeertaylor/pixelate", build_vignettes = TRUE, dependencies = TRUE)
```

## Example

As an example, we will show how to use blockdss to perform disease mapping of covid-19 incidence and to represent in a single-map incidence and geostatistical uncertainty.

Two datasets are required to run blockdss: 

1. point data, with incidence data per region,
2. block data, a regular grid dataset with id region values (blocks) at grid nodes.

In this example, blockdss functions are used to map covid-19 incidence in Portugal on 15 January 2021. The covid dataset `ptdata` and the regular grid `ptgrid` comes with the package `blockdss`. The coordinate reference system is ETRS89 / Portugal TM06 (EPSG: 3763) and coordinates are in metres.

```{r, warning = F, message = F}
# load required libraries
library(blockdss)
library(sp)
library(raster)

data(ptdata)
data(ptgrid)
```

Disease data is a data frame with spatial data point locations, region id, number of disease cases and size of population. Block data refers to a rectangular grid with region id values at all simulation x,y coordinates (grid nodes). All id regions represented in disease data should be represented by 1 or more grid nodes.

We need to transform `ptgrid` to `SpatialPixelsDataFrame`:

```{r ptgrid transform, warning = F, message = F, eval = T}
library(sp)
coordinates(ptgrid) <- ~x+y
proj4string(ptgrid) <- CRS("+init=epsg:3763")
class(ptgrid)
gridded(ptgrid) <- TRUE
class(ptgrid)
```

#### Compute incidence rates

Compute incidence rates and variance-error term per region, with function `irates()`:

```{r fun rates-var, eval = F}
# compute incidence rates
inc <- irates(dfobj = ptdata, oid = "oid_", xx = "x", yy = "y", zz = "t", 
               cases = "ncases", pop = "pop19", casesNA = 1, day = "20210115")
```

An incidence file (.out) is also created in a readable format for dss.c.64.exe and stored in './input' folder.

#### Create block file for dss.c.64.exe

A gridded file with block data (.out) is also required for block simulation with dss.c.64.exe. `blockfile()` function transforms the gridded data (blocks) into a readable format for dss.c.64.exe and saves it into a text file (.out) in './input' folder.

```{r fun block-data, warning = F, message = F, eval = F}
# create block file
block <- blockfile(rateobj = inc, gridimage = ptgrid, NAval = -999)
```

#### Create mask file for dss.c.64.exe

A mask for the block file is required for dss.c.64.exe. `maskfile()` function produces the required file (.out). The only argument of the function is the name of list, output of function `blockfile()`.

```{r fun mask-file, eval = F}
mask <- maskfile(block)
```

The function returns a list of objects and generates a text file (.out) with values {-1,0} where -1 are assigned to nodata locations and 0 are assigned to nodes with values (id region). The file is stored in `./input` folder.

#### Compute incidence rate semi-variogram 

Use `varexp()` to calculate experimental variogram from COVID-19 rates.
For now, it is only implemented in omnidirectional case.

```{r fun varexp, eval = F}
# compute experimental variogram
vexp <- varexp(inc, lag = 7000, nlags = 15)

# plot experimental variogram
plot(vexp[["semivar"]][1:2], ylab = expression(paste(gamma, "(h)")), xlab = "h (in m)", main = "Semi-variogram") 

# add estimated (weighted) sill
abline(h = vexp[["weightsvar"]], col ="red", lty = 2)
```

The function returns a list with the weighted variance (by population size) and variogram estimates at nlags.

#### Fit incidence rate semi-variogram 

Function `varmodel()` fits (manually) a theoretical variogram. You should provide the experimental variogram data to evaluate fit by visual inspection, the variogram model type and the variogram parameters. For now, only spherical and exponential models are implemented.

```{r fun varmodel, eval = F}
vmod <- varmodel(vexp, mod = "sph", nug = 0, ran = 35000, sill = vexp[["weightsvar"]])
```

Plotting the fitted model:

```{r varmodel-plot, out.width = "50%", fig.align = "center", eval = F}
# plot experimental variogram
plot(vexp[["semivar"]][1:2], ylab = expression(paste(gamma, "(h)")), xlab = "h (in m)") 

# add estimated sill
abline(h = vexp[["weightsvar"]], col ="red", lty = 2)

# add theoretical model
lines(vmod[["fittedval"]]) 
```

#### Create parameter file and invokes dss.c.64.exe

Function `ssdpars()` generates a parameters file (.par) and invokes dss.c.64.exe specified by the parameters file.

```{r fun ssdir, eval = F}
ssdpars(blockobj = block, maskobj = mask, dfobj = inc, varmobj = vmod, 
        simulations = 5, radius1 = 35000, radius2 = 35000)
```

Note that this process may take a while, depending mostly on the number of simulation nodes and number of simulations specified. In the end of the process, the block simulation maps are stored in .out format.

Both parameters file (.par) and simulations files (.out) are stored in `./input` folder.

#### Import dss.c.64.exe grid outputs in R readable formats

`outraster()` allows to import to R the .out files generated by dss.c.64.exe with a single-argument function

```{r fun outraster, eval = F}
maps <- outraster(block)
```

#### Plotting disease map results

Plot simulations: 

```{r spplot sims, eval = F}
raster::spplot(maps[["simulations"]])
```

`spmap()` to plot median e-type and spatial uncertainty maps:

```{r, message = F, warning=F, eval = F}
library(ggplot2)
library(pixelate)
spmap(maps, mapvar = "etype", legname = "Median \n incidence")
spmap(maps, mapvar = "uncertainty", legname = "IQ range")
```

`pxmap()` to plot pixelated map:

```{r, message = F, warning = F, eval = F}
pxmap(mapobj = maps)
```


## Acknowledgements

Manuel Ribeiro acknowledges the financial support of the CERENA (project FCT-UIDB/04028/2020) and Fundação para a Ciencia e Tecnologia (research contract IF2018-CP1384). Manuel Ribeiro gratefully acknowledge CERENA-IST/UL researchers Leonardo Azevedo, Maria João Pereira and Amilcar Soares for the code in Matlab and Fortran.

