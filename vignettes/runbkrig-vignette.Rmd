---
title: "Geostatistical disease risk mapping using blockdss package"
author: Manuel  Ribeiro, CERENA-IST/UL
output: rmarkdown::html_vignette
toc: true
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(runbkrig)
```

## 1 Introduction

This tutorial shows how to run block sequential simulation in R using `blockdss` package for modeling the spatial distribution of a disease, as in Azevedo et al. 2020^[https://doi.org/10.1186/s12942-020-00221-5]. For that purpose we will follow an example using COVID-19 data where simulated risk maps, median risk map and risk uncertainty map are obtained in the end.

The `blockdss` package provides the parameters and generate files to be read by an .exe program (dss.c.64.exe) performing block sequential simulation (using direct sequential simulation algorithm, Soares 2000^[https://doi.org/10.1023/A:1012246006212]).

## 2 Before you start

Some of the functions will require other functions available in external packages `raster` ($\ge 3.0.4$) and `data.table` ($\ge 1.12.8$). If not installed, these packages should be previously downloaded and installed from CRAN repositories.  

Make sure to save the COVID-19 cases file in default (working) directory. Inside that directory create a folder called `input` and put the dss.c.64.exe inside.

## 3 `blockdss` package

The `blockdss` package provides functions to configure a file with parameters and arguments needed to invoke dss.c.64.exe and run block simulation program. The functions added to the package are: `irates()`, `blockfile()`, `maskfile()`, `varexp()`, `varmodel()`, `ssdpars()` and `outraster()`.

## 4 COVID-19 example

For our example we will use a COVID-19 dataset for Portugal mainland with all cases notified to health authorities on 01/06/2020. The example is a step-by-step guide to obtain simulated risk maps of COVID-19, median risk map (median e-type map) and risk uncertainty map. All resources needed to follow the example - datasets, R package,  dss.64.c.exe - are available on the github repository.

The following datasets are needed :

- a COVID-19 datafile and,
- a georeferenced grid map with id region values at all simulation locations.

Supported file types for the grid map are the 'native' `raster` package format and those that can be read via `rgdal`.  

### 4.1 COVID-19 data

As input you should provide a data frame with id of region, x, y and z cartesian coordinates at region mass center (*centroid*), number of COVID-19 cases by region and population at risk by region. 

Therefore we start by reading an ascii file with the COVID-19 data and create a data frame from it.

```{r covid-data}
covid = read.table("covid19_data.txt", header = TRUE, sep = "\t", dec = ".")
```

```{r covid-data2}
head(covid)
str(covid)
```
You may see dataset contains regions where number of cases are missing (id regions 3 and 4). NA's must be replaced by an integer, for kriging to run. Function `irates()` includes an argument to overcome this limitation. 

### 4.2 Source functions

I created separate files for each function. Beacause code needs to run in a certain order, functions are numbered. 
Start by running the following code via source:
```{r source-files, echo = T, results='hide'}
source("f1_irates.R", echo = T)
source("f2_blockfile.R", echo = T)
source("f3_maskfile.R", echo = T)
source("f4_varexp.R", echo = T)
source("f5_varmodel.R", echo = T)
source("f6_ssdpars.R", echo = T)
source("f7_outraster.R", echo = T)
```

### 4.3 Compute rates (/10^4) and variance-error terms with `irates()`

Syntax:
```{r args irates, echo = F}
str(args(irates))
```

Use `irates()` to compute rates (/10^4), variance-error terms by region.
The arguments of the function are:

- `dfobj`, string, dataframe name with COVID-19 data
- `oid`, character, field name for region id
- `xx`, character, field name for x-coordinates 
- `yy`, character, field name for y-coordinates 
- `zz`, character, field name for z-coordinates 
- `cases`, character, field name for number of cases 
- `pop`, character, field name for population size
- `casesNA`, numeric, an integer used to replace rows with cases = NA,
- `day`, character, string indicating date (format "yyyymmdd") of COVID-19 data  


```{r fun rates-var}
rates = irates(dfobj = covid, oid = "id_region", xx = "xcoord", yy = "ycoord", zz = "zcoord", 
               cases = "ncases", pop = "poprisk", casesNA = 2, day = "20200601")
```

The function `irates()` returns the following list of objects:
```{r rates-var-return}
str(rates)
```

It also writes a text file (.out) with rates and store it in `input` folder. 

### 4.4 Create block with `blockfile()`

Syntax:
```{r args blockfile, echo = F}
str(args(blockfile))
```

Use `blockfile()` to transform grid file in block format. The function requires some libraries to be loaded. If not installed they will be first installed.

You should provide a georeferenced grid file with id region values at simulation locations.
The arguments of the function are:

- `rateobj`, string, name of list, output of function `irates()`. 
- `gridimage`, character,  name of georeferenced grid file (e.g. tif) 
- `na.value`, numeric, integer with grid value for "No data"  

```{r fun block-data, warning = F, message = F}
block = blockfile(rates, "grid2k.tif")
```

The grid file values should refer to the region id's at simulation locations (nodes). All regions in covid data should be represented by 1 or more node. 

The function writes a text file (.out) with blockdata and store it in `input` folder. `blockfile()` also returns the following list of objects:

```{r block-data-return}
str(block, max.level = 2)
```

### 4.5 Create mask with `maskfile()`

Syntax:
```{r args maskfile, echo = F}
str(args(maskfile))
```

The function `maskfile()` creates a mask for the block file. The only argument of the function is the name of list, output of function `blockfile()`.

```{r fun mask-file}
mask = maskfile(block)
```

The function returns the following a list of objects and generates a text file (.out) with values {-1,0} where -1 are assigned to nodata locations and 0 are assigned to nodes with values (id region). The file is stored in `input` folder. 

```{r mask-file-return}
str(mask)
```

### 4.6 Calculate experimental variogram with `varexp()`

Syntax:
```{r args varexp, echo = F}
str(args(varexp))
```

Use `varexp()` to calculate experimental variogram from COVID-19 rates.
Only implemented in omnidirectional case.
The arguments are:

- `dfobj`, string, name of list, output of function `irates()`
- `lag`, numeric, the lag distance used for variogram estimates 
- `nlags`, numeric, the number of lags to calculate variogram.

```{r fun varexp}
vexp = varexp(rates, lag = 7000, nlags = 15)
```

The function returns a list with the weighted variance (by population size) and variogram estimates at nlags.

```{r varexp-str}
str(vexp)
```

```{r varexp-plot, out.width = "50%", fig.align = "center"}
plot(vexp[["semivar"]], ylab = expression(paste(gamma, "(h)")), xlab = "h (in m)") 
```

### 4.7 Fit variogram model with `varmodel()`

Syntax:
```{r args varmodel, echo = F}
str(args(varmodel))
```

Funtion `varmodel()` fits (manually) a theoretical variogram. You should provide the experimental variogram data to evaluate fit by visual inspection, the variogram model type and the variogram parameters.
The arguments of `varmodel()` are:

- `varexp`, string, name of object, output of function varexp() 
- `mod`, character, the variogram model type (available are: "Sph" or "Exp")
- `nug`, numeric, nugget-effect value of the variogram
- `ran`, numeric, range value of the variogram
- `sill`, numeric, sill (or partial sill) value of the variogram

```{r fun varmodel}
vmod = varmodel(vexp, mod = "Exp", nug = 0, ran = 60000, sill = vexp[["weightsvar"]])
```

`varmodel()` returns the following list of objects:

```{r varmodel-str}
str(vmod)
```

```{r varmodel-plot, out.width = "50%", fig.align = "center"}
# plot experimental variogram
plot(vexp[["semivar"]], ylab = expression(paste(gamma, "(h)")), xlab = "h (in m)") 
# add sill
abline(h = vexp[["weightsvar"]], col ="red", lty = 2)
# add theoretical model
lines(vmod[["fittedval"]]) 
```

### 4.8 Create parameters file with `ssdpars()`

Syntax:
```{r args ssdpars , echo = F}
str(args(ssdpars))
```

Function `ssdpars()` generates a parameters file (.par) and the simulated maps in .out format. Function `ssdpars()` invokes dss.c.64.exe specified by the parameters file.

Arguments include names of lists and parameter values required for simulation processes:

- `blockobj`, string, name of list, output of function blockfile()
- `maskobj`, string, name of list, output of function maskfile()
- `dfobj`, string, name of list, output of function irates()
- `varmobj`, string, name of list, output of function varmodel()
- `simulations`, numeric, number of simulations
- `nrbias`, numeric, nr simulations for bias correction
- `biascor`, num vector, flag for (mean, variance) correction (yes = 1, no = 0)
- `ndMin`, numeric, min number of neighbour observations used in  kriging
- `ndMax`, numeric, max number of neighbour observations used in  kriging
- `nodMax`, numeric, max number of previously simulated nodes used in  kriging
- `radius1`, numeric, search radii in the major horizontal axe
- `radius2`, numeric, search radii in the axe orthogonal (horizontal) to radius1
- `radius3`, numeric, search radii in the vertical axe
- `ktype`, numeric, the kriging type to be used (available are: 0 = simple, 1 = ordinary)  

Note that this process may take a while, depending mostly on the number of simulation nodes and number of simulations specified.

```{r fun ssdir, eval = F}
ssdpars(blockobj = block, maskobj = mask, dfobj = rates, varmobj = vmod, 
        simulations = 5, radius1 = 60000, radius2 = 60000)
```

Both parameters file (.par) and simulations files (.out) are stored in `input` folder.

### 4.9 Obtain risk maps with `outraster()`

Syntax:
```{r args outraster, echo = F}
str(args(outraster))
```

Function `outraster()` read simulation files (.out) returned by `ssdpars()` and returns a list with simulated maps (rasterstack object), e-type and uncertainty maps (rasterlayers). 

The arguments of the function:

- `blockobj`, string,  name of list, output of function `blockfile()`,
- if `grids = T`,  saves simulated maps in 'native' raster package format .grd,
- if `emaps = T` (default), saves e-type and uncertainty maps in format .grd.

All .grd files are stored in `input` folder.

```{r fun outraster}
maps = outraster(block)
```

```{r str outraster obj}
str(maps, max.level = 3)
```

```{r spplot sims }
spplot(maps[["simulations"]])
```

```{r spplot etype, out.width = "50%", fig.align = "center"}
spplot(maps[["etype"]])
```

```{r spplot uncert, out.width = "50%", fig.align = "center"}
spplot(maps[["uncertainty"]])
```

## Acknowledgements

Manuel Ribeiro acknowledges the financial support of the CERENA (project FCT-UIDB/04028/2020) and Fundação para a Ciencia e Tecnologia (research contract IF2018-CP1384). Manuel Ribeiro gratefully acknowledge CERENA-IST/UL researchers Leonardo Azevedo, Maria João Pereira and Amilcar Soares for the code in Matlab and Fortran.

